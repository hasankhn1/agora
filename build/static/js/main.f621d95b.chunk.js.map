{"version":3,"sources":["components/ChannelForm.js","components/Call.js","App.js","serviceWorker.js","index.js"],"names":["ChannelForm","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","onChange","e","_e$target","target","name","value","setState","defineProperty","onSubmit","preventDefault","console","log","state","channel","selectChannel","react_default","a","createElement","placeholder","type","Component","client","AgoraRTC","createClient","mode","codec","USER_ID","uuid","APP_ID","Call","localStream","createStream","streamID","audio","video","screen","mediaSource","remoteStreams","initLocalStream","init","play","err","initClient","subscribeToClient","on","onStreamAdded","onRemoteClientAdded","onStreamRemoved","onPeerLeave","screenShare","setScreenProfile","evt","stream","getId","objectSpread","remoteStream","subscribe","joinChannel","uid","join","publish","streamId","stop","onLeave","leave","onLeaveMeeting","prevProps","prevState","_this2","id","style","width","height","onClick","keys","map","key","concat","App","className","ChannelForm_ChannelForm","Call_Call","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f621d95b.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nexport default class ChannelForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      channel: \"\"\n    };\n  }\n  onChange = e => {\n    let { name, value } = e.target;\n    this.setState({ [name]: value });\n  };\n  onSubmit = e => {\n    e.preventDefault();\n    console.log(\"Submiting \", this.state.channel);\n    this.props.selectChannel(this.state.channel);\n    this.setState({ channel: \"\" });\n  };\n  render() {\n    return (\n      <div>\n        <form onSubmit={this.onSubmit}>\n          <label>Channel Name</label>\n          <input\n            placeholder=\"Channel Name\"\n            name=\"channel\"\n            value={this.state.channel}\n            onChange={this.onChange}\n          />\n          <input type=\"submit\" value=\"Join Channel\" />\n        </form>\n      </div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport AgoraRTC from \"agora-rtc-sdk\";\nimport { v4 as uuid } from 'uuid';\nlet client = AgoraRTC.createClient({ mode: \"live\", codec: \"h264\" });\n\nconst USER_ID = uuid()\nconst APP_ID = \"1c721d1e1404469382d7d9b70d7f6bfa\";\n\nexport default class Call extends Component {\n  localStream = AgoraRTC.createStream({\n    streamID: USER_ID,\n    audio: true,\n    video: true,\n    screen: false,\n    mediaSource: 'screen'\n  });\n\n  state = {\n    remoteStreams: []\n  };\n\n  componentDidMount() {\n    this.initLocalStream();\n    this.initClient();\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.channel !== this.props.channel && this.props.channel !== \"\") {\n      this.joinChannel();\n    }\n  }\n\n  \n\n  initLocalStream = () => {\n    this.localStream.init(\n      () => {\n        console.log(\"getUserMedia successfully\");\n        this.localStream.play(\"agora_local\");\n      },\n      (err) => {\n        console.log(\"getUserMedia failed\", err);\n      }\n    );\n  };\n\n  initClient = () => {\n    client.init(\n      APP_ID,\n      () => {\n        console.log(\"AgoraRTC client initialized\");\n      },\n      (err) => {\n        console.log(\"AgoraRTC client init failed\", err);\n      }\n    );\n    this.subscribeToClient();\n  };\n\n  subscribeToClient = () => {\n    client.on(\"stream-added\", this.onStreamAdded);\n    client.on(\"stream-subscribed\", this.onRemoteClientAdded);\n    client.on(\"stream-removed\", this.onStreamRemoved);\n    client.on(\"peer-leave\", this.onPeerLeave);\n  };\n\n  screenShare = () => {\n    this.localStream.setScreenProfile(\"480p_1\")\n\n  }\n\n  onStreamAdded = evt => {\n    let stream = evt.stream;\n    console.log(\"New stream added: \" + stream.getId());\n    this.setState(\n      {\n        remoteStreams: {\n          ...this.state.remoteStream,\n          [stream.getId()]: stream\n        }\n      },\n      () => {\n        client.subscribe(stream, (err) => {\n          console.log(\"Subscribe stream failed\", err);\n        });\n      }\n    );\n  };\n\n  joinChannel = () => {\n    let uid = uuid()\n    client.join(\n      '0061c721d1e1404469382d7d9b70d7f6bfaIAAjk9Y8v3wkS00767AqQ0THI8UeZjoSisuVYwf6AoaQHqu95ggAAAAAEAAEa9nr3rJBYAEAAQDeskFg',\n      this.props.channel,\n      uid,\n      (uid) => {\n        console.log(\"User \" + uid + \" join channel successfully\");\n        client.publish(this.localStream, (err) => {\n          console.log(\"Publish local stream error: \" + err);\n        });\n\n        client.on(\"stream-published\", (evt) => {\n          console.log(\"Publish local stream successfully\");\n        });\n      },\n      (err) => {\n        console.log(\"Join channel failed\", err);\n      }\n    );\n  };\n\n  onRemoteClientAdded = evt => {\n    let remoteStream = evt.stream;\n    this.state.remoteStreams[remoteStream.getId()].play(\n      \"agora_remote \" + remoteStream.getId()\n    );\n  };\n\n  onStreamRemoved = evt => {\n    let stream = evt.stream;\n    if (stream) {\n      let streamId = stream.getId();\n      let { remoteStreams } = this.state;\n\n      stream.stop();\n      delete remoteStreams[streamId];\n\n      this.setState({ remoteStreams });\n\n      console.log(\"Remote stream is removed \" + stream.getId());\n    }\n  };\n\n  onLeave = (streamId) => {\n    client.leave(() => {\n      console.log(\"client leaves channel\");\n    }, (err) => {\n      console.log(\"client leave failed \", err);\n      //error handling\n    });\n  }\n\n  onLeaveMeeting = () => {\n    this.localStream.stop()\n    client.leave();\n  }\n\n  onPeerLeave = evt => {\n    let stream = evt.stream;\n    if (stream) {\n      let streamId = stream.getId();\n      let { remoteStreams } = this.state;\n\n      stream.stop();\n      delete remoteStreams[streamId];\n      this.setState({ remoteStreams });\n\n      console.log(evt.uid + \" leaved from this channel\");\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        <div id=\"agora_local\" style={{ width: \"400px\", height: \"400px\" }} />\n        <button onClick={(e) => this.onLeaveMeeting(e)}>Leave Meeting</button>\n        {Object.keys(this.state.remoteStreams).map(key => {\n          let stream = this.state.remoteStreams[key];\n          let streamId = stream.getId();\n          return (\n            <div key={streamId}>\n              <div\n                id={`agora_remote ${streamId}`}\n                style={{ width: \"400px\", height: \"400px\" }}\n              >\n              </div>\n              <button id={streamId} onClick={() => this.onLeave(streamId)}>Leave Meeting</button>\n            </div>\n          );\n        })}\n        <button onClick={()=>this.screenShare()}></button>\n      </div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport ChannelForm from \"./components/ChannelForm\";\nimport Call from \"./components/Call\";\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      channel: \"\"\n    };\n  }\n\n  selectChannel = channel => {\n    this.setState({ channel });\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        <ChannelForm selectChannel={this.selectChannel} />\n        <Call channel={this.state.channel} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}